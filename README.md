# Ghostbusters-Bayes-Nets
Ghostbusters and BNs
The goal here is to hunt down scared but invisible ghosts. Pacman, ever resourceful, is equipped with sonar (ears) that provides noisy readings of the Manhattan distance to each ghost. The game ends when Pacman has eaten all the ghosts. To start, try playing a game yourself using the keyboard.

python busters.py

The blocks of color indicate where the each ghost could possibly be, given the noisy distance readings provided to Pacman. The noisy distances at the bottom of the display are always non-negative, and always within 7 of the true distance. The probability of a distance reading decreases exponentially with its difference from the true distance.

Implemented inference to track the ghosts. All squares in which a ghost could possibly be are shaded by the color of the ghost. Naturally, we want a better estimate of the ghost's position. Fortunately, Bayes' Nets provide us with powerful tools for making the most of the information we have. Implement algorithms for performing exact inference using Bayes' Nets.

The autograder has 2 types of tests in this project, as differentiated by their *.test files found in the subdirectories of the test_cases folder. For tests of class DoubleInferenceAgentTest, the visualizations of the inference distributions generated by the code is seen, but all Pacman actions will be preselected according to the actions of the staff implementation. This is necessary in order to allow comparison of the project's distributions with the staff's distributions. The second type of test is GameScoreTest, in which the BustersAgent will actually select actions for Pacman and Pacman will play and win games.

To run a specific test case run the following command
python autograder.py -t test_cases/q1/1-ExactObserve
In general, all test cases can be found inside test_cases/q*.

##Exact Inference Observation
Updated the observe method in ExactInference class of inference.py to correctly update the agent's belief distribution over ghost positions given an observation from Pacman's sensors. When a ghost is eaten, that ghost is then placed in its prison cell, as described in the comments of observe.

To run the autograder for this question and visualize the output:

python autograder.py -q q1

###Notes: 
Busters agents have a separate inference module for each ghost they are tracking. That's why if you print an observation inside the observe function, you'll only see a single number even though there may be multiple ghosts on the board.

Implemented the online belief update for observing new evidence. Before any readings, Pacman believes the ghost could be anywhere: a uniform prior (see initializeUniformly). After receiving a reading, the observe function is called, which must update the belief at every position.


In the Pacman display, high posterior beliefs are represented by bright colors, while low beliefs are represented by dim colors. 
Beliefs are stored as util.Counter objects (like dictionaries) in a field called self.beliefs, which is getting updated.
The evidences are not stored. The only thing which is stored in ExactInference is self.beliefs.

##Exact Inference with Time Elapse
In the previous section belief updates for Pacman based on his observations is updated. Fortunately, Pacman's observations are not his only source of knowledge about where a ghost may be. Pacman also has knowledge about the ways that a ghost may move; namely that the ghost can not move through a wall or more than one space in one timestep.

To understand why this is useful to Pacman, consider the following scenario in which there is Pacman and one Ghost. Pacman receives many observations which indicate the ghost is very near, but then one which indicates the ghost is very far. The reading indicating the ghost is very far is likely to be the result of a buggy sensor. Pacman's prior knowledge of how the ghost may move will decrease the impact of this reading since Pacman knows the ghost could not move so far in only one move.

In this section, the elapseTime method in ExactInference is implemented. The agent has access to the action distribution for any GhostAgent. In order to test the elapseTime implementation separately from the observe implementation in the previous section, this section will not make use of the observe implementation.

Since Pacman is not utilizing any observations about the ghost, this means that Pacman will start with a uniform distribution over all spaces, and then update his beliefs according to how he knows the Ghost is able to move. Since Pacman is not observing the ghost, this means the ghost's actions will not impact Pacman's beliefs. Over time, Pacman's beliefs will come to reflect places on the board where he believes ghosts are most likely to be given the geometry of the board and what Pacman already knows about their valid movements.

For the tests in this section we will sometimes use a ghost with random movements and other times we will use the GoSouthGhost. This ghost tends to move south so over time, and without any observations, Pacman's belief distribution should begin to focus around the bottom of the board. To see which ghost is used for each test case you can look in the .test files.

To run the autograder for this question and visualize the output:

python autograder.py -q q2

As an example of the GoSouthGhostAgent, you can run

python autograder.py -t test_cases/q2/2-ExactElapse

and observe that the distribution becomes concentrated at the bottom of the board.

As you watch the autograder output, remember that lighter squares indicate that pacman believes a ghost is more likely to occupy that location, and darker squares indicate a ghost is less likely to occupy that location. 

Note:

Instructions for obtaining a distribution over where a ghost will go next, given its current position and the gameState, appears in the comments of ExactInference.elapseTime in inference.py.
We assume that ghosts still move independently of one another, so while developing all of the code for one ghost at a time, adding multiple ghosts still works correctly.

#Exact Inference Full Test
Now that Pacman knows how to use both his prior knowledge and his observations when figuring out where a ghost is, he is ready to hunt down ghosts on his own. This question will use the observe and elapseTime implementations together, along with a simple greedy hunting strategy which you will implement for this question. In the simple greedy strategy, Pacman assumes that each ghost is in its most likely position according to its beliefs, then moves toward the closest ghost. Up to this point, Pacman has moved by randomly selecting a valid action.

Implement the chooseAction method in GreedyBustersAgent in bustersAgents.py. Your agent should first find the most likely position of each remaining (uncaptured) ghost, then choose an action that minimizes the distance to the closest ghost. If correctly implemented, your agent should win the game in q3/3-gameScoreTest with a score greater than 700 at least 8 out of 10 times. Note: the autograder will also check the correctness of your inference directly, but the outcome of games is a reasonable sanity check.

To run the autograder for this question and visualize the output:

python autograder.py -q q3
Note: If you want to run this test (or any of the other tests) without graphics you can add the following flag:

python autograder.py -q q3 --no-graphics
Hints:

When correctly implemented, your agent will thrash around a bit in order to capture a ghost.
The comments of chooseAction provide you with useful method calls for computing maze distance and successor positions.
Make sure to only consider the living ghosts, as described in the comments.
